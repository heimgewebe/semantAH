name: Publish Knowledge Observatory

on:
  schedule:
    - cron: '15 06 * * *' # nach insights.daily, leicht versetzt
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'scripts/observatory_mvp.py'
      - 'contracts/knowledge.observatory.schema.json'
      - '.github/workflows/publish-knowledge-observatory.yml'

concurrency:
  group: publish-knowledge-observatory
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: astral-sh/setup-uv@v4
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: uv sync

      - name: Generate Knowledge Observatory
        run: |
          mkdir -p artifacts
          uv run scripts/observatory_mvp.py

          if [[ ! -s artifacts/knowledge.observatory.json ]]; then
            echo "Error: artifacts/knowledge.observatory.json missing or empty!"
            ls -la artifacts/
            exit 1
          fi

      - name: Setup Node (for AJV)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Validate (contracts)
        run: |
          # Strict only on main/schedule to prevent toolchain drift from blocking PRs
          if [[ "${{ github.event_name }}" == "schedule" || "${{ github.ref }}" == "refs/heads/main" ]]; then
            STRICT=1
          else
            STRICT=0
          fi

          echo "Validation Strictness: $STRICT"

          # NOTE: Contract uses x-* metadata (x-producers/x-consumers).
          # AJV strict rejects unknown keywords, so we disable strict mode here.
          npx --yes ajv-cli@5 validate --spec=draft2020 \
            --strict=false \
            -s contracts/knowledge.observatory.schema.json \
            -d artifacts/knowledge.observatory.json \
            || (echo "WARN: Validation failed" && [ "$STRICT" = "1" ] && exit 1 || exit 0)

      - name: Publish Release Asset
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: knowledge-observatory
        run: |
          gh release view "$RELEASE_TAG" \
            || gh release create "$RELEASE_TAG" --title "Knowledge Observatory" --notes "Automated publish of knowledge.observatory.json."
          gh release edit "$RELEASE_TAG" --prerelease=false
          gh release upload "$RELEASE_TAG" artifacts/knowledge.observatory.json --clobber

          # Debug: Log URLs
          OWNER="heimgewebe"
          REPO="semantAH"
          ASSET="knowledge.observatory.json"

          # 1. API URL (internal use)
          echo "::notice title=Asset API URL::$(gh release view "$RELEASE_TAG" --json assets -q '.assets[] | select(.name=="knowledge.observatory.json") | .url')"

          # 2. Canonical Download URL (for consumers like Leitstand)
          echo "::notice title=Canonical Download URL::https://github.com/${OWNER}/${REPO}/releases/download/${RELEASE_TAG}/${ASSET}"

      - name: Notify Plexer (knowledge.observatory)
        id: notify
        if: ${{ success() && secrets.PLEXER_URL != '' && secrets.PLEXER_TOKEN != '' }}
        continue-on-error: true
        env:
          PLEXER_URL: ${{ secrets.PLEXER_URL }}
          PLEXER_TOKEN: ${{ secrets.PLEXER_TOKEN }}
          RELEASE_TAG: knowledge-observatory
        run: |
          set -euo pipefail

          # Skip if secrets are not available
          if [[ -z "${PLEXER_URL:-}" || -z "${PLEXER_TOKEN:-}" ]]; then
            echo "::notice::PLEXER_URL or PLEXER_TOKEN not set, skipping notification."
            exit 0
          fi

          TS="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          URL="https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/knowledge.observatory.json"

          # generated_at aus dem Artefakt ziehen (falls vorhanden), sonst TS als fallback
          GEN_AT="$(python3 - <<'PY'
          import json
          from pathlib import Path

          p = Path("artifacts/knowledge.observatory.json")
          try:
              obj = json.loads(p.read_text(encoding="utf-8"))
              print(obj.get("generated_at") or obj.get("meta", {}).get("generated_at") or "")
          except Exception:
              print("")
          PY
          )"
          if [ -z "${GEN_AT}" ]; then GEN_AT="${TS}"; fi

          # Calculate SHA256 of the artifact (portable)
          if ! SHA=$( (sha256sum artifacts/knowledge.observatory.json 2>/dev/null || shasum -a 256 artifacts/knowledge.observatory.json) | cut -d ' ' -f 1 ); then
            echo "::error::SHA calculation failed for artifacts/knowledge.observatory.json"
            exit 1
          fi

          # Ensure 64-character hex format
          if [[ ! "$SHA" =~ ^[a-f0-9]{64}$ ]]; then
            echo "::error::Invalid SHA format: $SHA"
            exit 1
          fi

          # Apply canonical prefix
          SHA="sha256:$SHA"

          # Extract canonical Schema Ref from contract (fallback to hardcoded if missing)
          SCHEMA_REF=$(jq -r '."$id"' contracts/knowledge.observatory.schema.json 2>/dev/null || true)
          if [[ -z "${SCHEMA_REF}" || "${SCHEMA_REF}" == "null" ]]; then
            SCHEMA_REF="https://schemas.heimgewebe.org/contracts/knowledge.observatory.schema.json"
          fi

          echo "::notice::Notifying Plexer: ts=${TS}, generated_at=${GEN_AT}, url=${URL}, sha=${SHA}, schema_ref=${SCHEMA_REF}"

          cat > event.json <<EOF
          {
            "type": "knowledge.observatory.published.v1",
            "source": "semantAH",
            "payload": {
              "ts": "${TS}",
              "url": "${URL}",
              "generated_at": "${GEN_AT}",
              "sha": "${SHA}",
              "schema_ref": "${SCHEMA_REF}"
            }
          }
          EOF

          # Send to Plexer with X-Auth header (preferred) and capture response for debugging
          if ! curl -X POST "${PLEXER_URL%/}/events" \
            -H "Content-Type: application/json" \
            -H "X-Auth: ${PLEXER_TOKEN}" \
            -d @event.json \
            --fail-with-body \
            -o plexer_response.txt 2>plexer_error.log; then

            echo "::warning::Failed to notify plexer."

            # Redact secrets from logs (robust python replacement)
            python3 -c "import os, pathlib; tok=os.environ.get('PLEXER_TOKEN',''); [pathlib.Path(f).write_text(pathlib.Path(f).read_text().replace(tok, '[REDACTED]')) for f in ['plexer_error.log', 'plexer_response.txt'] if pathlib.Path(f).exists() and tok]" || true

            echo "::group::Plexer Debug Logs"
            cat plexer_error.log || true
            cat plexer_response.txt || true
            echo "::endgroup::"

            # Save logs as artifact for post-mortem, but do not fail the release
            mkdir -p plexer_logs
            cp event.json plexer_logs/
            cp plexer_response.txt plexer_logs/
            cp plexer_error.log plexer_logs/
            exit 1
          fi

      - name: Upload Plexer Debug Logs
        if: always() && steps.notify.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: plexer-notification-logs-observatory
          path: plexer_logs/
          if-no-files-found: ignore
          retention-days: 3
